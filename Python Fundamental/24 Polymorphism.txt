### Part 1: Theory of Polymorphism in Python

#### What is Polymorphism in Python?
Polymorphism is a core principle of Object-Oriented Programming (OOP) in Python that allows objects of different classes to be treated as objects of a common base class, enabling them to respond to the same method call in different ways. The term "polymorphism" means "many forms," reflecting the ability of different classes to implement the same method or interface differently. In Python, polymorphism is achieved primarily through method overriding, duck typing, and operator overloading. As of 2025, polymorphism remains essential for writing flexible, reusable, and maintainable code in Python, especially in frameworks like Django, FastAPI, and libraries like Pydantic or TensorFlow.

#### Key Components
1. **Method Overriding**:
   - A child class redefines a parent class’s method to provide a specific implementation.
   - Example:
     ```python
     class Animal:
         def speak(self):
             return "Sound"
     class Dog(Animal):
         def speak(self):
             return "Woof!"
     ```

2. **Duck Typing**:
   - Python’s dynamic typing allows objects to be used based on their behavior (methods/attributes) rather than their explicit type.
   - Example: If an object has a `speak()` method, it can be used polymorphically regardless of its class.
   - Phrase: "If it walks like a duck and quacks like a duck, it’s a duck."

3. **Operator Overloading**:
   - Special methods (e.g., `__add__`, `__eq__`) allow custom behavior for operators like `+` or `==`.
   - Example:
     ```python
     class Point:
         def __init__(self, x):
             self.x = x
         def __add__(self, other):
             return Point(self.x + other.x)
     ```

4. **Abstract Base Classes (ABCs)**:
   - Using the `abc` module, abstract methods enforce polymorphic behavior in child classes.
   - Example:
     ```python
     from abc import ABC, abstractmethod
     class Animal(ABC):
         @abstractmethod
         def speak(self):
             pass
     ```

5. **Interfaces via Protocols (Structural Subtyping)**:
   - Introduced in Python 3.8 (`typing.Protocol`), protocols define implicit interfaces for duck typing with type hints.
   - Example:
     ```python
     from typing import Protocol
     class Speakable(Protocol):
         def speak(self) -> str:
             pass
     ```

#### How Polymorphism Works
- **Mechanism**:
  - Polymorphism allows a single interface (method name or operator) to represent different behaviors based on the object’s class.
  - When a method is called on an object, Python dynamically dispatches the call to the appropriate class’s implementation.
- **Method Resolution**:
  - In inheritance, Python uses the Method Resolution Order (MRO) to determine which method to call.
  - Example: `Child.__mro__` shows the order of classes searched.
- **Dynamic Dispatch**:
  - Python resolves method calls at runtime, enabling flexibility in polymorphic behavior.
  - Example: A list of mixed objects `[Dog(), Cat()]` can call `speak()` on each, getting different results.
- **Type Flexibility**:
  - Duck typing allows any object with the required method to be used polymorphically without explicit inheritance.

#### Key Features
- **Flexibility**:
  - Polymorphism enables code to work with diverse objects without knowing their exact types.
  - Example: A function can process any object with a `speak()` method.
- **Code Reusability**:
  - Common interfaces reduce code duplication by allowing shared method names across classes.
- **Extensibility**:
  - New classes can be added with their own implementations without modifying existing code.
- **Runtime Polymorphism**:
  - Achieved through method overriding and dynamic dispatch.
- **Compile-Time Polymorphism**:
  - Python doesn’t support traditional compile-time polymorphism (e.g., method overloading), but operator overloading simulates it.

#### Use Cases
- **Modeling Real-World Entities**:
  - Different animals implementing a `speak()` method differently (e.g., `Dog`, `Cat`).
- **Web Development**:
  - **FastAPI**: Polymorphic response models using Pydantic inheritance.
  - **Django**: Model inheritance for polymorphic database queries.
- **Machine Learning**:
  - TensorFlow/PyTorch: Polymorphic layers or models with shared interfaces.
- **Testing**:
  - Mock objects implementing the same interface as real objects in `pytest`.
- **Frameworks in 2025**:
  - **Pydantic**: Polymorphic data validation with inherited models.
  - **SQLAlchemy**: Polymorphic ORM models for database queries.
  - **Streamlit/Dash**: Components with shared interfaces for UI rendering.

#### Advanced Concepts
- **Protocols and Structural Subtyping**:
  - Using `typing.Protocol`, classes implicitly implement interfaces if they have the required methods.
  - Example:
    ```python
    class Dog:
        def speak(self):
            return "Woof!"
    def process(s: Speakable) -> str:
        return s.speak()
    ```
- **Multiple Inheritance**:
  - Polymorphism works with multiple parent classes, resolved via MRO.
  - Example: A class inheriting from multiple bases can override methods from each.
- **Operator Overloading**:
  - Customize operators like `+`, `==`, or `<` for polymorphic behavior.
  - Example: `Point(1) + Point(2)` can return a new `Point`.
- **Mixins**:
  - Small classes for multiple inheritance to add polymorphic behavior.
  - Example:
    ```python
    class Printable:
        def print(self):
            return f"Printing {self.__class__.__name__}"
    class Dog(Animal, Printable):
        pass
    ```
- **Type Hints**:
  - Use `typing.Protocol` or `typing.Union` to enforce polymorphic interfaces.
  - Example: `def process(obj: Speakable) -> str`.
- **Performance**:
  - **Time Complexity**:
    - Method dispatch: O(1) for direct calls, O(n) for deep MRO in complex inheritance.
  - **Space Complexity**: O(1) per object for method references.
- **Asynchronous Polymorphism**:
  - Polymorphic async methods in FastAPI or `asyncio` applications.
  - Example:
    ```python
    class AsyncAnimal:
        async def speak(self):
            pass
    ```

#### Best Practices
- Use clear, consistent method names for polymorphic interfaces.
- Leverage abstract base classes to enforce required methods.
- Use `super()` for cooperative inheritance in polymorphic hierarchies.
- Apply type hints or protocols for type-safe polymorphism.
- Test polymorphic behavior with `pytest` to ensure correct implementations.
- Avoid overly complex inheritance to prevent MRO confusion.
- Use duck typing for flexibility but validate behavior in critical systems.
- In 2025, integrate polymorphism with Pydantic/FastAPI for API models or Django for ORM.
- Document overridden methods to clarify their purpose.

#### Layman’s Explanation of Polymorphism
Polymorphism is like having a universal remote control that works differently for each device. You press “play” (the same button/method), but a TV plays a show, a radio plays music, and a toy plays a sound. Each device (class) responds in its own way to the same command, making the system flexible and reusable.

---

### Part 2: Top 30 Interview Questions for a 4-Year Experienced Python Developer (Focused on Polymorphism)

Below are 30 interview questions tailored for a Python developer with 4 years of experience, focusing on polymorphism. Each question includes the expected answer, sample code (provided inline as requested), and a layman’s explanation, designed to be relevant for 2025.

#### Question 1
**Question**: What is polymorphism in Python?  
**Expected Answer**: Polymorphism allows objects of different classes to be treated as instances of a common base class, responding differently to the same method call.  
**Sample Code**:
```python
class Animal:
    def speak(self):
        return "Sound"
class Dog(Animal):
    def speak(self):
        return "Woof!"
class Cat(Animal):
    def speak(self):
        return "Meow!"
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.speak())  # Output: Woof!
                           #         Meow!
```
**Layman’s Explanation**: Polymorphism is like pressing “play” on different devices, getting different results like barking or meowing.

---

#### Question 2
**Question**: How is polymorphism achieved through method overriding?  
**Expected Answer**: A child class redefines a parent class’s method to provide a specific implementation, called dynamically at runtime.  
**Sample Code**:
```python
class Vehicle:
    def move(self):
        return "Moving"
class Car(Vehicle):
    def move(self):
        return "Driving"
car = Car()
print(car.move())  # Output: Driving
```
**Layman’s Explanation**: Overriding is like a car shop changing the parent’s “move” instruction to say “driving” instead.

---

#### Question 3
**Question**: What is duck typing in Python?  
**Expected Answer**: Duck typing allows objects to be used based on their methods/attributes, not their type, enabling polymorphic behavior.  
**Sample Code**:
```python
class Dog:
    def speak(self):
        return "Woof!"
class Cat:
    def speak(self):
        return "Meow!"
def make_sound(animal):
    return animal.speak()
print(make_sound(Dog()))  # Output: Woof!
print(make_sound(Cat()))  # Output: Meow!
```
**Layman’s Explanation**: Duck typing is like using any device with a “play” button, not caring if it’s a TV or radio.

---

#### Question 4
**Question**: How do you use operator overloading for polymorphism?  
**Expected Answer**: Define special methods like `__add__` or `__eq__` to customize operator behavior for different classes.  
**Sample Code**:
```python
class Point:
    def __init__(self, x):
        self.x = x
    def __add__(self, other):
        return Point(self.x + other.x)
    def __str__(self):
        return f"Point({self.x})"
p1 = Point(1)
p2 = Point(2)
print(p1 + p2)  # Output: Point(3)
```
**Layman’s Explanation**: Operator overloading is like teaching a toy to add its numbers differently when you press “+”.

---

#### Question 5
**Question**: How do abstract base classes support polymorphism?  
**Expected Answer**: ABCs enforce a common interface using `@abstractmethod`, ensuring child classes implement specific methods.  
**Sample Code**:
```python
from abc import ABC, abstractmethod
class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass
class Dog(Animal):
    def speak(self):
        return "Woof!"
dog = Dog()
print(dog.speak())  # Output: Woof!
```
**Layman’s Explanation**: ABCs are like a rule saying every device must have a “play” button, but each decides what it plays.

---

#### Question 6
**Question**: How does polymorphism work with inheritance?  
**Expected Answer**: Child classes override parent methods, allowing polymorphic behavior when called through a parent reference.  
**Sample Code**:
```python
class Animal:
    def speak(self):
        return "Sound"
class Cat(Animal):
    def speak(self):
        return "Meow!"
animal = Cat()  # Treated as Animal
print(animal.speak())  # Output: Meow!
```
**Layman’s Explanation**: Inheritance with polymorphism is like a child shop using the parent’s “greet” sign but saying its own greeting.

---

#### Question 7
**Question**: What is the role of `super()` in polymorphic hierarchies?  
**Expected Answer**: `super()` calls a parent class’s method, enabling cooperative polymorphism in inheritance.  
**Sample Code**:
```python
class Animal:
    def speak(self):
        return "Sound"
class Dog(Animal):
    def speak(self):
        return super().speak() + " and Woof!"
dog = Dog()
print(dog.speak())  # Output: Sound and Woof!
```
**Layman’s Explanation**: `super()` is like asking the parent shop to say its greeting before adding your own.

---

#### Question 8
**Question**: How does Method Resolution Order (MRO) affect polymorphism?  
**Expected Answer**: MRO determines which method is called in a polymorphic hierarchy, especially in multiple inheritance.  
**Sample Code**:
```python
class A:
    def method(self):
        return "A"
class B(A):
    def method(self):
        return "B"
class C(A):
    pass
class D(B, C):
    pass
d = D()
print(d.method())  # Output: B
print(D.__mro__)  # Output: (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
```
**Layman’s Explanation**: MRO is like a priority list for which shop’s “play” button to use when a device has multiple parents.

---

#### Question 9
**Question**: How do you use polymorphism with duck typing in Python?  
**Expected Answer**: Call methods on objects that implement them, regardless of their class, without explicit inheritance.  
**Sample Code**:
```python
class Bird:
    def fly(self):
        return "Flying"
class Airplane:
    def fly(self):
        return "Jet flying"
def take_off(obj):
    return obj.fly()
print(take_off(Bird()))      # Output: Flying
print(take_off(Airplane()))  # Output: Jet flying
```
**Layman’s Explanation**: Duck typing is like pressing “fly” on anything that can fly, whether it’s a bird or a plane.

---

#### Question 10
**Question**: How do you use protocols for polymorphism in 2025?  
**Expected Answer**: Use `typing.Protocol` to define implicit interfaces for duck typing with type checking.  
**Sample Code**:
```python
from typing import Protocol
class Speakable(Protocol):
    def speak(self) -> str:
        pass
class Dog:
    def speak(self):
        return "Woof!"
def process(s: Speakable) -> str:
    return s.speak()
print(process(Dog()))  # Output: Woof!
```
**Layman’s Explanation**: Protocols are like saying any device with a “play” button can be used, with a label for safety.

---

#### Question 11
**Question**: How do you implement polymorphism in FastAPI in 2025?  
**Expected Answer**: Use Pydantic models with inheritance to create polymorphic response models.  
**Sample Code**:
```python
from fastapi import FastAPI
from pydantic import BaseModel
app = FastAPI()
class User(BaseModel):
    name: str
class Admin(User):
    role: str
@app.get("/user", response_model=Admin)
async def get_user():
    return Admin(name="Alice", role="admin")
# Run: uvicorn script:app --reload
# Test: curl http://127.0.0.1:8000/user
# Output: {"name": "Alice", "role": "admin"}
```
**Layman’s Explanation**: In FastAPI, polymorphism is like using a user form for an admin, adding a role field.

---

#### Question 12
**Question**: How do you use polymorphism in Django in 2025?  
**Expected Answer**: Use model inheritance or `django-polymorphic` for polymorphic database queries.  
**Sample Code**:
```python
from django.db import models
class Animal(models.Model):
    def speak(self):
        return "Sound"
class Dog(Animal):
    def speak(self):
        return "Woof!"
# Output: Database table with polymorphic behavior
dog = Dog()
print(dog.speak())  # Output: Woof!
```
**Layman’s Explanation**: In Django, polymorphism is like a dog table using the animal table’s “speak” but barking instead.

---

#### Question 13
**Question**: How do you use polymorphism with operator overloading?  
**Expected Answer**: Define special methods like `__eq__` to make operators behave differently for different classes.  
**Sample Code**:
```python
class Vector:
    def __init__(self, x):
        self.x = x
    def __eq__(self, other):
        return self.x == other.x
v1 = Vector(1)
v2 = Vector(1)
print(v1 == v2)  # Output: True
```
**Layman’s Explanation**: Operator overloading is like teaching a toy to compare its numbers when you press “==”.

---

#### Question 14
**Question**: How does polymorphism work with multiple inheritance?  
**Expected Answer**: Child classes inherit methods from multiple parents, with MRO determining which method is called.  
**Sample Code**:
```python
class A:
    def greet(self):
        return "Hello from A"
class B:
    def greet(self):
        return "Hello from B"
class C(A, B):
    pass
c = C()
print(c.greet())  # Output: Hello from A
```
**Layman’s Explanation**: With multiple parents, polymorphism is like picking one shop’s greeting based on a priority list.

---

#### Question 15
**Question**: How do you test polymorphic behavior with `pytest`?  
**Expected Answer**: Use `pytest` to test different implementations of a method across classes.  
**Sample Code**:
```python
import pytest
class Animal:
    def speak(self):
        return "Sound"
class Dog(Animal):
    def speak(self):
        return "Woof!"
def test_polymorphism():
    assert Dog().speak() == "Woof!"
# Run: pytest script.py
# Output: Test passes
```
**Layman’s Explanation**: Testing polymorphism is like checking if a device plays the right sound when you press “play”.

---

#### Question 16
**Question**: How do you use polymorphism with mixins?  
**Expected Answer**: Mixins add polymorphic behavior via multiple inheritance, providing reusable methods.  
**Sample Code**:
```python
class Printable:
    def print(self):
        return f"Printing {self.__class__.__name__}"
class Animal:
    def speak(self):
        return "Sound"
class Dog(Animal, Printable):
    def speak(self):
        return "Woof!"
dog = Dog()
print(dog.print())  # Output: Printing Dog
```
**Layman’s Explanation**: A mixin is like adding a “print” button to a dog shop, alongside its barking feature.

---

#### Question 17
**Question**: How do you handle polymorphism with async methods in 2025?  
**Expected Answer**: Define `async def` methods in parent/child classes for polymorphic async behavior.  
**Sample Code**:
```python
import asyncio
class AsyncAnimal:
    async def speak(self):
        return "Sound"
class AsyncDog(AsyncAnimal):
    async def speak(self):
        return "Woof!"
async def main():
    dog = AsyncDog()
    print(await dog.speak())  # Output: Woof!
asyncio.run(main())
```
**Layman’s Explanation**: Async polymorphism is like a device playing sounds slowly, with each device choosing its sound.

---

#### Question 18
**Question**: How do you use polymorphism with Pydantic in 2025?  
**Expected Answer**: Inherit from `BaseModel` to create polymorphic models for data validation.  
**Sample Code**:
```python
from pydantic import BaseModel
class User(BaseModel):
    name: str
class Admin(User):
    role: str
admin = Admin(name="Alice", role="admin")
print(admin)  # Output: name='Alice' role='admin'
```
**Layman’s Explanation**: In Pydantic, polymorphism is like adding extra fields to a user form for an admin, keeping the same structure.

---

#### Question 19
**Question**: How do you implement polymorphism without inheritance?  
**Expected Answer**: Use duck typing or protocols to call methods on objects with matching interfaces.  
**Sample Code**:
```python
class Dog:
    def bark(self):
        return "Woof!"
class Cat:
    def bark(self):
        return "Meow!"
def make_noise(animal):
    return animal.bark()
print(make_noise(Dog()))  # Output: Woof!
print(make_noise(Cat()))  # Output: Meow!
```
**Layman’s Explanation**: Polymorphism without inheritance is like pressing “bark” on any device that has it, not caring about its type.

---

#### Question 20
**Question**: How do you use polymorphism in machine learning with TensorFlow in 2025?  
**Expected Answer**: Define models or layers with a common interface, allowing different implementations.  
**Sample Code**:
```python
import tensorflow as tf
class Model:
    def predict(self, x):
        return x
class NeuralNet(Model):
    def predict(self, x):
        return x * 2
model = NeuralNet()
print(model.predict(1))  # Output: 2
```
**Layman’s Explanation**: In TensorFlow, polymorphism is like different models predicting differently but using the same “predict” button.

---

#### Question 21
**Question**: How do you use type hints with polymorphism?  
**Expected Answer**: Use `typing.Protocol` or `typing.Union` to define polymorphic interfaces for type checking.  
**Sample Code**:
```python
from typing import Protocol
class Speakable(Protocol):
    def speak(self) -> str:
        pass
class Dog:
    def speak(self):
        return "Woof!"
def process(s: Speakable) -> str:
    return s.speak()
print(process(Dog()))  # Output: Woof!
```
**Layman’s Explanation**: Type hints for polymorphism are like labeling devices to ensure they have a “play” button.

---

#### Question 22
**Question**: How do you handle exceptions in polymorphic methods?  
**Expected Answer**: Catch exceptions in overridden methods or parent methods, raising specific errors as needed.  
**Sample Code**:
```python
class Animal:
    def move(self):
        raise NotImplementedError("Must implement move")
class Dog(Animal):
    def move(self):
        try:
            return "Running"
        except Exception as e:
            raise ValueError(f"Error: {e}")
dog = Dog()
print(dog.move())  # Output: Running
```
**Layman’s Explanation**: Exception handling in polymorphism is like a device catching errors when pressing “move” and reporting them.

---

#### Question 23
**Question**: How do you use polymorphism with SQLAlchemy in 2025?  
**Expected Answer**: Use polymorphic inheritance with `polymorphic_identity` for ORM queries.  
**Sample Code**:
```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()
class Animal(Base):
    __tablename__ = "animals"
    id = Column(Integer, primary_key=True)
    type = Column(String)
    __mapper_args__ = {"polymorphic_on": type}
class Dog(Animal):
    __mapper_args__ = {"polymorphic_identity": "dog"}
    def speak(self):
        return "Woof!"
dog = Dog()
print(dog.speak())  # Output: Woof!
```
**Layman’s Explanation**: In SQLAlchemy, polymorphism is like a dog table barking differently but stored as an animal.

---

#### Question 24
**Question**: How do you implement a factory pattern with polymorphism?  
**Expected Answer**: Use a factory method to create objects of different classes with a common interface.  
**Sample Code**:
```python
class Animal:
    def speak(self):
        return "Sound"
class Dog(Animal):
    def speak(self):
        return "Woof!"
class Cat(Animal):
    def speak(self):
        return "Meow!"
class Factory:
    @staticmethod
    def create_animal(type_):
        if type_ == "dog":
            return Dog()
        return Cat()
animal = Factory.create_animal("dog")
print(animal.speak())  # Output: Woof!
```
**Layman’s Explanation**: A factory with polymorphism is like a shop making either a dog or cat device, each with its own “play” sound.

---

#### Question 25
**Question**: How do you use polymorphism with iterators?  
**Expected Answer**: Define `__iter__` differently in child classes to provide polymorphic iteration behavior.  
**Sample Code**:
```python
class Animal:
    def __iter__(self):
        return iter(["Sound"])
class Dog(Animal):
    def __iter__(self):
        return iter(["Woof!", "Bark!"])
dog = Dog()
print(list(dog))  # Output: ['Woof!', 'Bark!']
```
**Layman’s Explanation**: Polymorphic iterators are like devices giving different lists of sounds when you press “next”.

---

#### Question 26
**Question**: How do you debug polymorphic behavior?  
**Expected Answer**: Use logging, print statements, or debuggers like `pdb` to trace method calls and MRO.  
**Sample Code**:
```python
class Animal:
    def speak(self):
        print("Calling Animal.speak")
        return "Sound"
class Dog(Animal):
    def speak(self):
        print("Calling Dog.speak")
        return "Woof!"
dog = Dog()
print(dog.speak())  # Output: Calling Dog.speak
                    #         Woof!
```
**Layman’s Explanation**: Debugging polymorphism is like checking which device’s “play” button was pressed and what it played.

---

#### Question 27
**Question**: How do you use polymorphism with composition?  
**Expected Answer**: Use objects with shared interfaces as attributes, allowing polymorphic behavior without inheritance.  
**Sample Code**:
```python
class Speaker:
    def speak(self):
        return "Sound"
class DogSpeaker:
    def speak(self):
        return "Woof!"
class Animal:
    def __init__(self, speaker):
        self.speaker = speaker
    def speak(self):
        return self.speaker.speak()
dog = Animal(DogSpeaker())
print(dog.speak())  # Output: Woof!
```
**Layman’s Explanation**: Composition with polymorphism is like a device using a swappable “speaker” part that plays different sounds.

---

#### Question 28
**Question**: How do you use polymorphism with `collections.abc`?  
**Expected Answer**: Inherit from `collections.abc` classes to implement polymorphic interfaces like `Iterable` or `Sequence`.  
**Sample Code**:
```python
from collections.abc import Iterable
class MyList:
    def __init__(self, data):
        self.data = data
    def __iter__(self):
        return iter(self.data)
mylist = MyList([1, 2, 3])
print(isinstance(mylist, Iterable))  # Output: True
print(list(mylist))  # Output: [1, 2, 3]
```
**Layman’s Explanation**: Using `collections.abc` is like making a device follow a standard “list” rule so it can act like a list.

---

#### Question 29
**Question**: How do you achieve polymorphism in function arguments?  
**Expected Answer**: Pass objects with a common interface to functions, relying on duck typing or protocols.  
**Sample Code**:
```python
class Dog:
    def action(self):
        return "Run"
class Cat:
    def action(self):
        return "Jump"
def perform(obj):
    return obj.action()
print(perform(Dog()))  # Output: Run
print(perform(Cat()))  # Output: Jump
```
**Layman’s Explanation**: Polymorphic arguments are like a remote working with any device that has an “action” button.

---

#### Question 30
**Question**: What are common pitfalls with polymorphism, and how can you avoid them?  
**Expected Answer**: Pitfalls include MRO confusion, missing methods, and tight coupling. Avoid by using ABCs, testing, and clear interfaces.  
**Sample Code**:
```python
from abc import ABC, abstractmethod
class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass
class Dog(Animal):
    def speak(self):
        return "Woof!"
# class Cat(Animal):  # Error: Missing speak()
dog = Dog()
print(dog.speak())  # Output: Woof!
```
**Layman’s Explanation**: Pitfalls are like a device missing a “play” button; use rules and tests to ensure every device works right.

---

This comprehensive guide covers the theory of polymorphism in Python and provides 30 interview questions with detailed answers, inline code samples, and layman’s explanations tailored for a 4-year experienced developer in 2025. Let me know if you need further clarification or additional topics!

<xaiArtifact artifact_id="f15857b2-6a7b-4649-b560-1574ccb63733" artifact_version_id="834c16b8-1fbf-496b-a3a6-4d596933a6b9" title="polymorphism_examples.py" contentType="text/python">
# Example 1: Method overriding
class Animal:
    def speak(self):
        return "Sound"
class Dog(Animal):
    def speak(self):
        return "Woof!"
class Cat(Animal):
    def speak(self):
        return "Meow!"
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.speak())  # Output: Woof!
                           #         Meow!

# Example 2: Duck typing
class Bird:
    def fly(self):
        return "Flying"
class Airplane:
    def fly(self):
        return "Jet flying"
def take_off(obj):
    return obj.fly()
print(take_off(Bird()))      # Output: Flying
print(take_off(Airplane()))  # Output: Jet flying

# Example 3: Operator overloading
class Point:
    def __init__(self, x):
        self.x = x
    def __add__(self, other):
        return Point(self.x + other.x)
    def __str__(self):
        return f"Point({self.x})"
p1 = Point(1)
p2 = Point(2)
print(p1 + p2)  # Output: Point(3)

# Example 4: Abstract base class
from abc import ABC, abstractmethod
class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass
class Dog(Animal):
    def speak(self):
        return "Woof!"
dog = Dog()
print(dog.speak())  # Output: Woof!
</xaiArtifact>