### Part 1: Theory of Classes and Objects in Python

#### What are Classes and Objects in Python?
In Python, **classes** and **objects** are fundamental concepts of Object-Oriented Programming (OOP). A **class** is a blueprint or template for creating objects, defining their properties (attributes) and behaviors (methods). An **object** is an instance of a class, representing a specific entity that has the attributes and methods defined by the class. Introduced in Python’s early versions, classes and objects remain central to Python in 2025, widely used in frameworks like FastAPI, Django, and libraries like Pydantic for building robust applications.

#### Key Components
1. **Class Definition**:
   - Defined using the `class` keyword.
   - Syntax: `class ClassName:`
   - Example:
     ```python
     class Dog:
         def __init__(self, name):
             self.name = name
         def bark(self):
             return f"{self.name} says Woof!"
     ```

2. **Objects**:
   - Created by instantiating a class: `obj = ClassName()`.
   - Each object has its own set of attributes and can call the class’s methods.
   - Example: `dog = Dog("Buddy"); print(dog.bark())` outputs "Buddy says Woof!".

3. **Attributes**:
   - **Instance Attributes**: Defined in `__init__`, unique to each object (e.g., `self.name`).
   - **Class Attributes**: Shared across all instances, defined outside methods (e.g., `species = "Canis"`).
   - Example:
     ```python
     class Dog:
         species = "Canis"  # Class attribute
         def __init__(self, name):
             self.name = name  # Instance attribute
     ```

4. **Methods**:
   - Functions defined inside a class, typically taking `self` as the first parameter.
   - Types:
     - **Instance Methods**: Operate on instance attributes (use `self`).
     - **Class Methods**: Operate on the class, use `@classmethod` and `cls`.
     - **Static Methods**: Utility functions, use `@staticmethod`, no `self` or `cls`.
   - Example:
     ```python
     class Dog:
         @classmethod
         def get_species(cls):
             return cls.species
         @staticmethod
         def is_dog(name):
             return name.lower() in ["buddy", "max"]
     ```

5. **Constructor (`__init__`)**:
   - Special method called when an object is created, used to initialize attributes.
   - Example: `def __init__(self, name): self.name = name`.

#### How Classes and Objects Work
- **Class Creation**:
  - A class is defined with attributes (data) and methods (functions).
  - Acts as a template for creating objects.
- **Object Instantiation**:
  - Objects are created by calling the class like a function: `obj = ClassName(args)`.
  - Each object gets its own copy of instance attributes but shares class attributes.
- **Method Invocation**:
  - Methods are called on objects (e.g., `obj.method()`) or the class for class/static methods.
- **Memory**:
  - Objects store instance attributes in their own memory space.
  - Class attributes are stored once in the class’s namespace.
  - Python’s garbage collector manages object lifecycle via reference counting.

#### Key Features
- **Encapsulation**:
  - Bundling data (attributes) and methods; use `_` or `__` for protected/private attributes.
  - Example: `_protected` or `__private` (name mangling for `__`).
- **Inheritance**:
  - A class can inherit from another using `class Child(Parent):`.
  - Supports single and multiple inheritance.
  - Example:
    ```python
    class Animal:
        def speak(self):
            pass
    class Dog(Animal):
        def speak(self):
            return "Woof!"
    ```
- **Polymorphism**:
  - Methods can be overridden in subclasses, allowing different behaviors for the same method name.
  - Example: `Dog().speak()` vs. `Cat().speak()`.
- **Abstraction**:
  - Hide implementation details using abstract base classes (ABCs) from `abc` module.
  - Example:
    ```python
    from abc import ABC, abstractmethod
    class Animal(ABC):
        @abstractmethod
        def speak(self):
            pass
    ```
- **Magic Methods**:
  - Special methods like `__str__`, `__len__`, `__add__` customize object behavior.
  - Example: `__str__` defines string representation: `def __str__(self): return self.name`.

#### Use Cases
- **Modeling Real-World Entities**:
  - Classes for users, products, or orders in web apps (e.g., Django models).
- **Data Validation**:
  - Pydantic models in 2025 use classes for API data validation.
  - Example: `class User(BaseModel): name: str`.
- **Machine Learning**:
  - Classes for models, datasets, or pipelines in TensorFlow/PyTorch.
- **Web Development**:
  - FastAPI/Django: Classes for routes, models, or middleware.
- **Testing**:
  - Classes for test suites or fixtures in `pytest`.
- **Frameworks in 2025**:
  - **FastAPI**: Classes for dependency injection or response models.
  - **Django**: ORM models as classes.
  - **Pydantic**: Data validation with class-based models.
  - **Streamlit/Dash**: Component-based UIs with classes.

#### Advanced Concepts
- **Type Hints**:
  - Use `typing` module for class attributes and methods.
  - Example: `from typing import Optional; name: Optional[str]`.
- **Descriptors**:
  - Classes with `__get__`, `__set__`, or `__delete__` to control attribute access.
  - Example: `@property` for getter/setter methods.
- **Metaclasses**:
  - Classes that define how classes are created (e.g., `type` or custom metaclasses).
  - Example: `class Meta(type): pass; class MyClass(metaclass=Meta): pass`.
- **Multiple Inheritance**:
  - Inherit from multiple classes; use `super()` to resolve method calls.
  - Example: `class Child(Base1, Base2): pass`.
- **Performance**:
  - **Time Complexity**:
    - Method calls: O(1).
    - Attribute access: O(1).
    - Inheritance lookup: O(n) for deep hierarchies.
  - **Space Complexity**: O(n) for n instance attributes per object.
- **Asynchronous Classes**:
  - Use `async def` for methods in async applications (e.g., FastAPI).
  - Example:
    ```python
    class AsyncClass:
        async def process(self):
            await asyncio.sleep(1)
    ```
- **Integration with Libraries**:
  - Pydantic: Class-based models with validation.
  - SQLAlchemy: Classes for database ORM.
  - Pytest: Classes for organizing test cases.

#### Best Practices
- Follow PEP 8 for class naming (CamelCase) and method naming (snake_case).
- Use `__init__` for initialization, keeping it simple.
- Use `@property` for controlled attribute access.
- Implement `__str__` or `__repr__` for readable object representations.
- Use inheritance judiciously to avoid complex hierarchies.
- Apply type hints for clarity in large codebases.
- Test classes with `pytest` or `unittest` for robust behavior.
- Use `abc` module for abstract base classes to enforce interfaces.
- Avoid excessive use of private attributes (`__`) unless necessary.
- In 2025, leverage classes with Pydantic/FastAPI for modern APIs.

#### Layman’s Explanation of Classes and Objects
A **class** is like a blueprint for a house, describing its structure (rooms, doors) and what it can do (open door, turn on light). An **object** is a specific house built from that blueprint, with its own details (like a red door or blue walls). You can build many houses (objects) from one blueprint (class), each with unique features but following the same design.

---

### Part 2: Top 30 Interview Questions for a 4-Year Experienced Python Developer (Focused on Classes and Objects)

Below are 30 interview questions tailored for a Python developer with 4 years of experience, focusing on classes and objects. Each question includes the expected answer, sample code (provided inline as requested), and a layman’s explanation, designed to be relevant for 2025.

#### Question 1
**Question**: What is a class and an object in Python?  
**Expected Answer**: A class is a blueprint defining attributes and methods; an object is an instance of a class with specific values.  
**Sample Code**:
```python
class Dog:
    def __init__(self, name):
        self.name = name
    def bark(self):
        return f"{self.name} says Woof!"
dog = Dog("Buddy")
print(dog.bark())  # Output: Buddy says Woof!
```
**Layman’s Explanation**: A class is a house blueprint; an object is a specific house named “Buddy” that can bark.

---

#### Question 2
**Question**: How do you define a class in Python?  
**Expected Answer**: Use the `class` keyword, followed by the class name and a colon, with methods and attributes inside.  
**Sample Code**:
```python
class Car:
    def __init__(self, model):
        self.model = model
    def drive(self):
        return f"{self.model} is driving"
car = Car("Toyota")
print(car.drive())  # Output: Toyota is driving
```
**Layman’s Explanation**: Defining a class is like drawing a blueprint for a car, saying it has a model and can drive.

---

#### Question 3
**Question**: What is the purpose of `__init__` in a class?  
**Expected Answer**: `__init__` is the constructor, called when an object is created, to initialize instance attributes.  
**Sample Code**:
```python
class Person:
    def __init__(self, name):
        self.name = name
person = Person("Alice")
print(person.name)  # Output: Alice
```
**Layman’s Explanation**: `__init__` is like setting up a house with a name when you build it from the blueprint.

---

#### Question 4
**Question**: What is the difference between instance and class attributes?  
**Expected Answer**: Instance attributes are unique to each object; class attributes are shared across all instances.  
**Sample Code**:
```python
class Dog:
    species = "Canis"  # Class attribute
    def __init__(self, name):
        self.name = name  # Instance attribute
dog1 = Dog("Buddy")
dog2 = Dog("Max")
print(dog1.name, dog1.species)  # Output: Buddy Canis
print(dog2.name, dog2.species)  # Output: Max Canis
```
**Layman’s Explanation**: Instance attributes are like a house’s unique paint color; class attributes are like the type of wood all houses use.

---

#### Question 5
**Question**: What are instance methods, class methods, and static methods?  
**Expected Answer**: Instance methods use `self`, class methods use `@classmethod` and `cls`, static methods use `@staticmethod` and no instance/class reference.  
**Sample Code**:
```python
class Dog:
    species = "Canis"
    def __init__(self, name):
        self.name = name
    def bark(self):  # Instance method
        return f"{self.name} barks"
    @classmethod
    def get_species(cls):  # Class method
        return cls.species
    @staticmethod
    def is_dog(name):  # Static method
        return name.lower() in ["buddy", "max"]
print(Dog("Buddy").bark())  # Output: Buddy barks
print(Dog.get_species())    # Output: Canis
print(Dog.is_dog("Buddy"))  # Output: True
```
**Layman’s Explanation**: Instance methods are like a house’s doorbell, class methods are about the house type, and static methods are general tools.

---

#### Question 6
**Question**: How does inheritance work in Python?  
**Expected Answer**: A class inherits attributes and methods from a parent class using `class Child(Parent):`.  
**Sample Code**:
```python
class Animal:
    def speak(self):
        return "Sound"
class Dog(Animal):
    def speak(self):
        return "Woof!"
dog = Dog()
print(dog.speak())  # Output: Woof!
```
**Layman’s Explanation**: Inheritance is like a new house design borrowing features from an older design but adding its own twist, like a unique sound.

---

#### Question 7
**Question**: What is method overriding in Python?  
**Expected Answer**: Method overriding occurs when a subclass redefines a parent class’s method with its own implementation.  
**Sample Code**:
```python
class Animal:
    def speak(self):
        return "Sound"
class Cat(Animal):
    def speak(self):
        return "Meow!"
cat = Cat()
print(cat.speak())  # Output: Meow!
```
**Layman’s Explanation**: Overriding is like changing the doorbell sound in a new house to “Meow” instead of the parent’s “Sound.”

---

#### Question 8
**Question**: How do you use `super()` in Python?  
**Expected Answer**: `super()` calls a parent class’s method, often used in `__init__` or overridden methods.  
**Sample Code**:
```python
class Animal:
    def __init__(self, species):
        self.species = species
class Dog(Animal):
    def __init__(self, name, species):
        super().__init__(species)
        self.name = name
dog = Dog("Buddy", "Canis")
print(dog.species)  # Output: Canis
```
**Layman’s Explanation**: `super()` is like asking the parent blueprint to set up part of the house before adding your own details.

---

#### Question 9
**Question**: What is encapsulation, and how is it achieved in Python?  
**Expected Answer**: Encapsulation hides data using `_` (protected) or `__` (private) attributes; Python uses name mangling for `__`.  
**Sample Code**:
```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance
    def get_balance(self):
        return self.__balance
account = BankAccount(100)
print(account.get_balance())  # Output: 100
# print(account.__balance)  # Raises AttributeError
```
**Layman’s Explanation**: Encapsulation is like locking a safe in a house; only special methods can open it to see the money.

---

#### Question 10
**Question**: How do you use the `@property` decorator in a class?  
**Expected Answer**: `@property` turns a method into a getter, allowing attribute-like access; use `@setter` for setting values.  
**Sample Code**:
```python
class Person:
    def __init__(self, name):
        self._name = name
    @property
    def name(self):
        return self._name
    @name.setter
    def name(self, value):
        self._name = value
person = Person("Alice")
print(person.name)  # Output: Alice
person.name = "Bob"
print(person.name)  # Output: Bob
```
**Layman’s Explanation**: `@property` is like a special door to a house’s room; you can look inside or change it safely.

---

#### Question 11
**Question**: What are magic methods in Python?  
**Expected Answer**: Magic methods (e.g., `__str__`, `__add__`) customize object behavior for operations like string representation or addition.  
**Sample Code**:
```python
class Point:
    def __init__(self, x):
        self.x = x
    def __str__(self):
        return f"Point({self.x})"
    def __add__(self, other):
        return Point(self.x + other.x)
p1 = Point(1)
p2 = Point(2)
print(p1 + p2)  # Output: Point(3)
```
**Layman’s Explanation**: Magic methods are like secret buttons in a house that control how it looks or adds up with another house.

---

#### Question 12
**Question**: How do you implement abstract base classes in Python?  
**Expected Answer**: Use the `abc` module with `ABC` and `@abstractmethod` to define methods that subclasses must implement.  
**Sample Code**:
```python
from abc import ABC, abstractmethod
class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass
class Dog(Animal):
    def speak(self):
        return "Woof!"
dog = Dog()
print(dog.speak())  # Output: Woof!
```
**Layman’s Explanation**: An abstract class is like a blueprint requiring every house to have a doorbell, but each house picks its sound.

---

#### Question 13
**Question**: How does multiple inheritance work in Python?  
**Expected Answer**: A class can inherit from multiple parents; Python uses Method Resolution Order (MRO) to resolve conflicts.  
**Sample Code**:
```python
class A:
    def greet(self):
        return "Hello from A"
class B:
    def greet(self):
        return "Hello from B"
class C(A, B):
    pass
c = C()
print(c.greet())  # Output: Hello from A
print(C.__mro__)  # Output: (<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```
**Layman’s Explanation**: Multiple inheritance is like a house combining features from two blueprints; Python decides which feature to use first.

---

#### Question 14
**Question**: What is Method Resolution Order (MRO) in Python?  
**Expected Answer**: MRO defines the order in which Python searches for methods in a class hierarchy, accessible via `__mro__`.  
**Sample Code**:
```python
class A:
    def method(self):
        return "A"
class B(A):
    def method(self):
        return "B"
class C(A):
    pass
class D(B, C):
    pass
d = D()
print(d.method())  # Output: B
print(D.__mro__)  # Output: (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
```
**Layman’s Explanation**: MRO is like a priority list for which blueprint’s instructions to follow when a house has multiple parents.

---

#### Question 15
**Question**: How do you use classes with Pydantic in 2025?  
**Expected Answer**: Pydantic uses classes to define data models with type validation, used in APIs like FastAPI.  
**Sample Code**:
```python
from pydantic import BaseModel
class User(BaseModel):
    name: str
    age: int
user = User(name="Alice", age=30)
print(user)  # Output: name='Alice' age=30
```
**Layman’s Explanation**: In Pydantic, a class is like a form template ensuring user data, like name and age, is valid before use.

---

#### Question 16
**Question**: How do you use classes in FastAPI in 2025?  
**Expected Answer**: Use classes for dependency injection, response models, or custom middleware in FastAPI.  
**Sample Code**:
```python
from fastapi import FastAPI, Depends
app = FastAPI()
class User:
    def __init__(self, name: str):
        self.name = name
def get_user():
    return User("Alice")
@app.get("/user")
async def read_user(user: User = Depends(get_user)):
    return {"name": user.name}
# Run: uvicorn script:app --reload
# Test: curl http://127.0.0.1:8000/user
# Output: {"name": "Alice"}
```
**Layman’s Explanation**: In FastAPI, classes are like templates for user data or services, used to manage API requests.

---

#### Question 17
**Question**: How do you use `@classmethod` in Python?  
**Expected Answer**: `@classmethod` defines a method that takes the class (`cls`) as the first argument, often for alternative constructors.  
**Sample Code**:
```python
class Dog:
    def __init__(self, name):
        self.name = name
    @classmethod
    def from_birth_year(cls, name, year):
        return cls(name)
dog = Dog.from_birth_year("Buddy", 2020)
print(dog.name)  # Output: Buddy
```
**Layman’s Explanation**: A class method is like a factory that builds a house using a different set of instructions.

---

#### Question 18
**Question**: How do you use `@staticmethod` in Python?  
**Expected Answer**: `@staticmethod` defines a method that doesn’t access instance or class data, used for utility functions.  
**Sample Code**:
```python
class Math:
    @staticmethod
    def add(x, y):
        return x + y
print(Math.add(2, 3))  # Output: 5
```
**Layman’s Explanation**: A static method is like a general tool in a toolbox, not tied to a specific house or blueprint.

---

#### Question 19
**Question**: How do you implement a singleton pattern in Python?  
**Expected Answer**: Ensure a class has only one instance using a class attribute or metaclass.  
**Sample Code**:
```python
class Singleton:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # Output: True
```
**Layman’s Explanation**: A singleton is like having only one main house for everyone, no matter how many times you try to build it.

---

#### Question 20
**Question**: How do you use descriptors in Python?  
**Expected Answer**: Descriptors are classes with `__get__`, `__set__`, or `__delete__` to control attribute access; often used with `@property`.  
**Sample Code**:
```python
class Descriptor:
    def __get__(self, obj, owner):
        return obj._value
    def __set__(self, obj, value):
        obj._value = value
class MyClass:
    value = Descriptor()
obj = MyClass()
obj.value = 10
print(obj.value)  # Output: 10
```
**Layman’s Explanation**: A descriptor is like a smart lock on a house’s door, controlling who can open or change it.

---

#### Question 21
**Question**: How do you use type hints with classes?  
**Expected Answer**: Use `typing` module to annotate attributes and methods for static type checking.  
**Sample Code**:
```python
from typing import Optional
class Person:
    def __init__(self, name: str, age: Optional[int] = None):
        self.name = name
        self.age = age
person = Person("Alice")
print(person.name, person.age)  # Output: Alice None
```
**Layman’s Explanation**: Type hints are like labels on a blueprint, saying what kind of data (like names or ages) a house can hold.

---

#### Question 22
**Question**: How do you handle exceptions in classes?  
**Expected Answer**: Use `try-except` in methods to catch and handle exceptions, possibly raising custom exceptions.  
**Sample Code**:
```python
class Calculator:
    def divide(self, a, b):
        try:
            return a / b
        except ZeroDivisionError:
            raise ValueError("Cannot divide by zero")
calc = Calculator()
try:
    print(calc.divide(10, 0))
except ValueError as e:
    print(e)  # Output: Cannot divide by zero
```
**Layman’s Explanation**: Exception handling in classes is like a house having a fire alarm that alerts you to problems, like dividing by zero.

---

#### Question 23
**Question**: How do you use classes with Django in 2025?  
**Expected Answer**: Define models as classes inheriting from `django.db.models.Model` for database ORM.  
**Sample Code**:
```python
from django.db import models
class User(models.Model):
    name = models.CharField(max_length=100)
    age = models.IntegerField()
    def __str__(self):
        return self.name
# Output: Represents a database table with name and age fields
```
**Layman’s Explanation**: In Django, a class is like a blueprint for a database table, defining fields like name and age.

---

#### Question 24
**Question**: How do you implement operator overloading in Python?  
**Expected Answer**: Use magic methods like `__add__`, `__eq__` to define behavior for operators.  
**Sample Code**:
```python
class Vector:
    def __init__(self, x, y):
        self.x, self.y = x, y
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    def __str__(self):
        return f"({self.x}, {self.y})"
v1 = Vector(1, 2)
v2 = Vector(3, 4)
print(v1 + v2)  # Output: (4, 6)
```
**Layman’s Explanation**: Operator overloading is like teaching a house to add its coordinates to another house’s coordinates.

---

#### Question 25
**Question**: How do you use classes in unit testing with `pytest`?  
**Expected Answer**: Define test classes with methods for related test cases, using `pytest` assertions.  
**Sample Code**:
```python
import pytest
class TestMath:
    def test_add(self):
        assert 1 + 1 == 2
# Run: pytest script.py
# Output: Test passes
```
**Layman’s Explanation**: Test classes are like organizing house inspections into groups, checking if everything works as expected.

---

#### Question 26
**Question**: How do you use metaclasses in Python?  
**Expected Answer**: Metaclasses define how classes are created, using `type` or a custom class with `__new__`.  
**Sample Code**:
```python
class Meta(type):
    def __new__(cls, name, bases, attrs):
        attrs["custom"] = "value"
        return super().__new__(cls, name, bases, attrs)
class MyClass(metaclass=Meta):
    pass
print(MyClass.custom)  # Output: value
```
**Layman’s Explanation**: A metaclass is like a master blueprint that decides how other blueprints are made, adding extra features.

---

#### Question 27
**Question**: How do you use async methods in classes in 2025?  
**Expected Answer**: Define methods with `async def` for asynchronous operations, used in frameworks like FastAPI.  
**Sample Code**:
```python
import asyncio
class AsyncClass:
    async def process(self):
        await asyncio.sleep(1)
        return "Done"
async def main():
    obj = AsyncClass()
    print(await obj.process())  # Output: Done
asyncio.run(main())
```
**Layman’s Explanation**: Async methods in classes are like house tasks that can wait without stopping other work, like waiting for a delivery.

---

#### Question 28
**Question**: How do you use classes with SQLAlchemy in 2025?  
**Expected Answer**: Define ORM models as classes inheriting from `declarative_base()` for database mapping.  
**Sample Code**:
```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    name = Column(String)
    def __str__(self):
        return self.name
# Output: Maps to a database table "users"
```
**Layman’s Explanation**: In SQLAlchemy, a class is like a blueprint for a database table, linking fields to columns.

---

#### Question 29
**Question**: How do you implement a factory pattern in Python?  
**Expected Answer**: Use a class method or separate class to create objects based on conditions.  
**Sample Code**:
```python
class Animal:
    @classmethod
    def create(cls, type_):
        if type_ == "dog":
            return Dog()
        return Cat()
class Dog:
    def speak(self):
        return "Woof!"
class Cat:
    def speak(self):
        return "Meow!"
animal = Animal.create("dog")
print(animal.speak())  # Output: Woof!
```
**Layman’s Explanation**: A factory is like a workshop that builds the right type of house (dog or cat) based on what you ask for.

---

#### Question 30
**Question**: What are common pitfalls with classes, and how can you avoid them?  
**Expected Answer**: Pitfalls include complex inheritance, mutable default arguments, and attribute shadowing. Avoid by keeping hierarchies simple, using immutable defaults, and naming carefully.  
**Sample Code**:
```python
# Bad: Mutable default
class Bad:
    def __init__(self, lst=[]):
        self.lst = lst
# Good: Immutable default
class Good:
    def __init__(self, lst=None):
        self.lst = lst or []
b1 = Bad()
b2 = Bad()
b1.lst.append(1)
print(b2.lst)  # Output: [1] (shared list)
g1 = Good()
g2 = Good()
g1.lst.append(1)
print(g2.lst)  # Output: [] (separate lists)
```
**Layman’s Explanation**: Pitfalls are like building a house with a shared toolbox that causes mix-ups; use separate tools for each house.

---

This comprehensive guide covers the theory of classes and objects in Python and provides 30 interview questions with detailed answers, inline code samples, and layman’s explanations tailored for a 4-year experienced developer in 2025. Let me know if you need further clarification or additional topics!

<xaiArtifact artifact_id="80491df1-7fef-4aea-83d9-5df971abefa1" artifact_version_id="04c21e31-8f3b-4900-ace8-f950c1ebad74" title="class_examples.py" contentType="text/python">
# Example 1: Basic class and object
class Dog:
    species = "Canis"
    def __init__(self, name):
        self.name = name
    def bark(self):
        return f"{self.name} says Woof!"
dog = Dog("Buddy")
print(dog.bark())  # Output: Buddy says Woof!
print(dog.species)  # Output: Canis

# Example 2: Inheritance and overriding
class Animal:
    def speak(self):
        return "Sound"
class Cat(Animal):
    def speak(self):
        return "Meow!"
cat = Cat()
print(cat.speak())  # Output: Meow!

# Example 3: Property decorator
class Person:
    def __init__(self, name):
        self._name = name
    @property
    def name(self):
        return self._name
    @name.setter
    def name(self, value):
        self._name = value
person = Person("Alice")
print(person.name)  # Output: Alice
person.name = "Bob"
print(person.name)  # Output: Bob

# Example 4: Abstract base class
from abc import ABC, abstractmethod
class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass
class Dog(Animal):
    def speak(self):
        return "Woof!"
dog = Dog()
print(dog.speak())  # Output: Woof!
</xaiArtifact>