Here is the comprehensive guide for Python Dictionaries, formatted as a single Markdown block for easy note-taking.

```markdown
# Python Dictionaries — Interview Guide (30 Questions)

**Target Audience:** Python Developer (4 Years Experience)
**Topic:** Python Dictionaries (Hash Maps, Internals, Optimization, Advanced Usage)
**Total Questions:** 30 (20 Theory, 10 Coding)

---

## SECTION 1 — THEORY QUESTIONS (20 TOTAL)

### Part A: Easy Level (6 Questions)

#### 1. Mutable Keys & Hashability

**Question:** Can you use a `list` as a dictionary key? Why or why not? What defines a "hashable" object?

**Expected Answer:** No, you cannot use a `list` as a key because lists are mutable. If the list changed, its hash would change, and the dictionary would lose track of where the value is stored.
A "hashable" object must have a hash value that never changes during its lifetime (needs `__hash__`) and can be compared to other objects (needs `__eq__`). Immutable types like strings, integers, and tuples (containing only immutable items) are hashable.

**Common Mistakes:** Thinking `tuple` is always hashable. `(1, [2])` is a tuple but is *not* hashable because it contains a list.

**Sample Code:**
d = {}
# d[[1, 2]] = "Error"  # Raises TypeError: unhashable type: 'list'
d[(1, 2)] = "Valid"    # Valid tuple

---

#### 2. Time Complexity (Lookup & Insertion)

**Question:** What is the average and worst-case time complexity for `d[key] = value` and `d[key]`? When does the worst case happen?

**Expected Answer:**
- **Average:** O(1) (Constant time).
- **Worst-Case:** O(N) (Linear time).
- **Explanation:** Worst case occurs when there are excessive hash collisions (many keys hashing to the same index). Python's collision resolution must probe the table to find the slot, degrading to linear scanning in extreme pathological cases.

**Why Interviewers Ask This:** To check if you understand that while dicts are fast, they are not magic; they depend on a good hash function.

---

#### 3. Handling Missing Keys (get vs [])

**Question:** What is the difference between accessing `d['key']` and `d.get('key')`? How does `setdefault` fit in?

**Expected Answer:**
- `d['key']`: Raises `KeyError` if the key is missing.
- `d.get('key', default)`: Returns `None` (or a specified default) if the key is missing. It does *not* modify the dictionary.
- `d.setdefault('key', default)`: If key exists, returns the value. If missing, *inserts* the key with the default value and returns that default.

**Sample Code:**
d = {'a': 1}
val = d.get('b', 0)      # val=0, d={'a': 1}
val2 = d.setdefault('b', 0) # val2=0, d={'a': 1, 'b': 0}

---

#### 4. Dictionary Ordering (Python 3.7+)

**Question:** Are Python dictionaries ordered? Has this always been the case?

**Expected Answer:** As of Python 3.7 (and as an implementation detail in 3.6), dictionaries **are insertion ordered**. When you iterate over them, items appear in the order they were inserted. Before 3.6, they were unordered (random-looking).

**Why Interviewers Ask This:** To see if you keep up with language updates. Relying on order in Python 2.7 or 3.5 was a bug; now it's a feature.

---

#### 5. Deletion Methods

**Question:** How do `del d[k]`, `d.pop(k)`, and `d.popitem()` differ?

**Expected Answer:**
- `del d[k]`: Removes key `k`. Returns nothing. Raises `KeyError` if missing.
- `d.pop(k)`: Removes key `k`. **Returns** the value associated with `k`. Allows a default return value to avoid errors.
- `d.popitem()`: Removes and returns the **last inserted** (key, value) pair (LIFO behavior in 3.7+).

---

#### 6. Dictionary Views

**Question:** What does `d.keys()` return? Is it a list? What happens if I modify the dictionary while holding this object?

**Expected Answer:** It returns a **View Object** (`dict_keys`), not a list. It is dynamic. If you modify the dictionary (e.g., add an item), the view object updates immediately to reflect that change.

**Sample Code:**
d = {'a': 1}
keys = d.keys()
d['b'] = 2
print(keys) # dict_keys(['a', 'b']) - It updated automatically!

---

### Part B: Medium/Internals (14 Questions)

#### 7. Internals: Collision Resolution

**Question:** How does Python handle hash collisions? Does it use Chaining (Linked Lists) or Open Addressing?

**Expected Answer:** Python uses **Open Addressing** with a specialized probing strategy (not simple linear probing).
When a collision occurs (two keys map to the same array index), Python calculates a "next" index using a pseudo-random permutation based on the hash bits. It keeps looking until it finds an empty slot. Python does *not* use linked lists (chaining) at each bucket.



**Why Interviewers Ask This:** High-level understanding of CPython internals distinguishes senior devs.

---

#### 8. The "Compact Dict" Optimization (Python 3.6+)

**Question:** Python 3.6 reduced the memory usage of dictionaries by 20-25%. How does the internal memory layout differ from older versions?

**Expected Answer:**
- **Old Way:** A large sparse array where every row held `(hash, key_ptr, value_ptr)`. Lots of empty space.
- **New Way (Compact):** Split into two arrays.
    1. `indices`: A dense array of bytes holding indices pointing to the entries array.
    2. `entries`: A dense array of `(hash, key, value)` appended in insertion order.
This structure is what enables Insertion Ordering naturally and saves significant memory by not storing empty 'entry' structs.

---

#### 9. Merging Dictionaries (Evolution)

**Question:** How do you merge two dictionaries `d1` and `d2`? How did this change in Python 3.9?

**Expected Answer:**
- **Old (pre-3.9):** `d1.update(d2)` (modifies in-place) or `{**d1, **d2}` (creates new).
- **New (3.9+):** The Union Operator `|`.
    - `new_d = d1 | d2` (Merge into new dict).
    - `d1 |= d2` (In-place update).

---

#### 10. The `__missing__` Method

**Question:** How can you customize a dictionary so that accessing a missing key doesn't raise a KeyError but instead runs custom logic?

**Expected Answer:** Subclass `dict` and implement `__missing__(self, key)`. This is actually how `collections.defaultdict` is implemented under the hood.

**Sample Code:**
class VerboseDict(dict):
    def __missing__(self, key):
        print(f"Missing {key}, returning None")
        return None

---

#### 11. defaultdict vs setdefault

**Question:** When should you use `collections.defaultdict` instead of standard `dict.setdefault()`?

**Expected Answer:**
- Use `defaultdict` when you want the default behavior to apply to **every** access automatically (cleaner code, usually faster inside loops).
- Use `setdefault` for one-off checks or when you are working with a plain dictionary you didn't create.
- **Performance:** `defaultdict` is generally faster because the default factory is called at the C level, whereas `setdefault` requires Python function calls and evaluating the arguments every time.

---

#### 12. Dictionary Comprehensions

**Question:** Transform a list of tuples `[('a', 1), ('b', 2)]` into a dictionary, but filter out values less than 2, using a comprehension.

**Expected Answer:**
`d = {k: v for k, v in data if v >= 2}`

**Why Interviewers Ask This:** Checks for Pythonic syntax usage over standard `for` loops.

---

#### 13. Thread Safety

**Question:** Is a dictionary thread-safe? specifically `d[key] = value`?

**Expected Answer:**
- Single operations like `d[k] = v` or `x = d[k]` are atomic in CPython due to the GIL (Global Interpreter Lock). You won't corrupt the memory structure.
- However, logic like `d[k] += 1` is **NOT** thread-safe. It involves three steps: get, add, set. Another thread can interrupt in between. Use `threading.Lock` for read-modify-write sequences.

---

#### 14. Keys: __eq__ and __hash__ relationship

**Question:** If you override `__eq__` in a class, why must you also override `__hash__` to use instances as dictionary keys?

**Expected Answer:** Python dictionaries check the hash first. If hashes are different, keys are different. If hashes are same (collision), it checks equality (`__eq__`).
If you override `__eq__` but not `__hash__`, the hash remains based on the memory address (default), meaning two "equal" objects will have different hashes and Python won't ever check `__eq__`, causing duplicate entries for logically identical keys.

---

#### 15. The `fromkeys` method Trap

**Question:** What is the potential issue with `dict.fromkeys(['a', 'b'], [])`?

**Expected Answer:** All keys will point to the **same** list object in memory. Modifying the list for 'a' will also modify the list for 'b'.
**Fix:** Use a dict comprehension `{k: [] for k in keys}` to create distinct lists.

---

#### 16. OrderedDict in 2024

**Question:** Now that standard dicts are ordered, is `collections.OrderedDict` useless?

**Expected Answer:** No, but its use case is niche.
1. **Equality:** `OrderedDict` considers order in equality checks (`OrderedDict([('a',1), ('b',2)]) != OrderedDict([('b',2), ('a',1)])`). Standard dicts do not.
2. **Reordering:** It has `move_to_end(key, last=True/False)` which is efficient for LRU caches. Standard dicts cannot efficiently move an item to the front/back.

---

#### 17. Sizing and Resizing

**Question:** What happens to the dictionary size when it gets two-thirds full?

**Expected Answer:** To maintain O(1) performance, the table must be sparse. When the "Load Factor" reaches roughly 2/3 (66%), Python creates a new, larger table (usually 2x size), re-hashes all existing keys, and inserts them into the new table. This is an O(N) operation.

---

#### 18. Dictionary as a Switch/Case

**Question:** Before Python 3.10 (Match/Case), how were dictionaries used to simulate Switch statements?

**Expected Answer:** By mapping keys to functions (first-class citizens).

**Sample Code:**
def action_a(): return "A"
def action_b(): return "B"
dispatch = {'a': action_a, 'b': action_b}
# Execute
result = dispatch.get(user_input, lambda: "Invalid")()

---

#### 19. Security: Hash DoS Attacks

**Question:** How does Python protect against Hash DoS attacks (where an attacker sends many keys that hash to the same value to slow down your server)?

**Expected Answer:** Python uses **Hash Randomization** (SipHash). When the Python process starts, it generates a random salt. This salt is mixed into the hash calculation for strings. This ensures that the specific hash values are unpredictable to an external attacker.

---

#### 20. Checking Membership

**Question:** Which is faster: `key in d` or `key in d.keys()`?

**Expected Answer:** In modern Python (3+), they are functionally identical because `d.keys()` returns a view, not a list. However, `key in d` is the cleaner, preferred, and slightly more direct Pythonic idiom. (In Python 2, `d.keys()` built a list, making it O(N) — terrible).

---

## SECTION 2 — CODING QUESTIONS (10 TOTAL)

### Part A: Easy Level (3 Questions)

#### 21. Character Frequency String

**Question:** Given a string, return a dictionary with the frequency of every character.

**Solution:**
```python
# Approach 1: Manual
def count_chars(s):
    freq = {}
    for char in s:
        freq[char] = freq.get(char, 0) + 1
    return freq

# Approach 2: Counter (Recommended for interviews)
from collections import Counter
def count_chars_pro(s):
    return dict(Counter(s))

```

---

#### 22. Invert a Dictionary

**Question:** Swap keys and values. If multiple keys have the same value, keep them in a list.
`{'a': 1, 'b': 2, 'c': 1}` -> `{1: ['a', 'c'], 2: ['b']}`

**Solution:**

```python
from collections import defaultdict

def invert_dict(d):
    # Using defaultdict avoids the "if key not in..." check
    inverted = defaultdict(list)
    for k, v in d.items():
        inverted[v].append(k)
    return dict(inverted)

```

**Complexity:** Time O(N), Space O(N).

---

#### 23. Sort Dictionary by Value

**Question:** Return a list of tuples `(key, value)` sorted by value in descending order.

**Solution:**

```python
d = {'apple': 5, 'banana': 2, 'cherry': 8}
sorted_items = sorted(d.items(), key=lambda item: item[1], reverse=True)
print(sorted_items)
# Output: [('cherry', 8), ('apple', 5), ('banana', 2)]

```

**Why Asked:** Tests knowledge of lambda functions and `sorted()` custom keys.

---

### Part B: Medium Level (7 Questions)

#### 24. Two Sum (Dict Approach)

**Question:** Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.
**Constraint:** O(N) Time.

**Solution:**

```python
def two_sum(nums, target):
    seen = {} # map value -> index
    for i, num in enumerate(nums):
        diff = target - num
        if diff in seen:
            return [seen[diff], i]
        seen[num] = i
    return []

```

**Concept:** Use the dictionary to store "what I need to find" or "what I have seen". Instant O(1) lookup beats O(N²) nested loops.

---

#### 25. Group Anagrams

**Question:** Group an array of strings into anagrams.
`["eat", "tea", "tan", "ate", "nat", "bat"]`

**Solution:**

```python
from collections import defaultdict

def group_anagrams(strs):
    anagram_map = defaultdict(list)
    for s in strs:
        # Tuple allows it to be a key (lists are not hashable)
        count_key = tuple(sorted(s)) 
        anagram_map[count_key].append(s)
    return list(anagram_map.values())

```

**Detailed Explanation:** We use the sorted version of the string as the "Signature" key.

---

#### 26. First Unique Character

**Question:** Find the first non-repeating character in a string and return its index. O(N) time.

**Solution:**

```python
from collections import Counter

def first_uniq_char(s):
    count = Counter(s) # First Pass: Count freqs O(N)
    for i, char in enumerate(s): # Second Pass: Check O(N)
        if count[char] == 1:
            return i
    return -1

```

**Concept:** Two-pass hash map algorithm.

---

#### 27. Intersection of Two Arrays (Elements)

**Question:** Given two arrays, compute their intersection. Each element in the result must appear as many times as it shows in both arrays.
`nums1 = [1,2,2,1], nums2 = [2,2]` -> `[2,2]`

**Solution:**

```python
from collections import Counter

def intersect(nums1, nums2):
    c1 = Counter(nums1)
    c2 = Counter(nums2)
    # The & operator on Counters calculates intersection of counts
    intersection = c1 & c2 
    return list(intersection.elements())

```

**Why Asked:** Tests knowledge of `Counter` arithmetic (Set theory applied to multisets).

---

#### 28. Longest Substring Without Repeating Characters

**Question:** Given a string, find the length of the longest substring without repeating characters.
`"abcabcbb"` -> `3` ("abc")

**Solution:**

```python
def length_of_longest_substring(s):
    char_map = {} # char -> index
    left = 0
    max_len = 0
    
    for right, char in enumerate(s):
        # If we see a dupe AND it's inside the current window
        if char in char_map and char_map[char] >= left:
            left = char_map[char] + 1
            
        char_map[char] = right
        max_len = max(max_len, right - left + 1)
        
    return max_len

```

**Concept:** Sliding Window optimized with a Hash Map to "jump" the left pointer instantly.

---

#### 29. Implement an LRU Cache (Simplified)

**Question:** Design a data structure that follows Least Recently Used constraints. O(1) get and put.

**Solution:**

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # Move to end to show it was recently used
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            # FIFO pop (pop first item)
            self.cache.popitem(last=False)

```

**Concept:** Combining Hash Map (fast lookup) with Doubly Linked List (fast reordering). `OrderedDict` abstracts this perfectly.

---

#### 30. Subarray Sum Equals K

**Question:** Find total continuous subarrays whose sum equals `k`. (Handling negatives, so sliding window doesn't work).

**Solution:**

```python
def subarray_sum(nums, k):
    count = 0
    curr_sum = 0
    # Map prefix_sum -> occurrence count
    # Base case: sum 0 occurs once (before starting)
    prefix_sums = {0: 1} 
    
    for num in nums:
        curr_sum += num
        diff = curr_sum - k
        
        if diff in prefix_sums:
            count += prefix_sums[diff]
            
        prefix_sums[curr_sum] = prefix_sums.get(curr_sum, 0) + 1
        
    return count

```

**Concept:** If `Sum(0 to i) = X` and `Sum(0 to j) = Y`, and `Y - X = K`, then the subarray from `i+1` to `j` sums to `K`. We store frequencies of prefix sums in the dict.

---

### Summary & Final Tips for Dictionaries

1. **Internals Matter:** For a 4-year dev, knowing *why* collisions happen and how Python handles them (Open Addressing + Random probing) is key.
2. **Hashability:** Always remember: Immutable = Hashable (mostly). Lists and Dicts cannot be keys.
3. **Performance:** Dictionaries trade memory for speed. They are O(1) but use significant RAM compared to lists/tuples.
4. **Modern Python:** Be aware of "Compact Dict" (3.6) and "Union Operators" (3.9).
5. **Tools:** Master `collections.defaultdict` and `collections.Counter`. They save lines of code and prevent bugs.

```

```
